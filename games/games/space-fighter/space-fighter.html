<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Fighter - Explore the Galaxy</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            overflow: hidden;
            background: #000;
            color: #0ff;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            z-index: 10;
            color: #0ff;
            text-shadow: 0 0 10px #0ff;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 16px;
        }

        .hud-stats {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border: 2px solid #0ff;
            border-radius: 5px;
        }

        .resources {
            text-align: right;
        }

        .resource-item {
            margin: 5px 0;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #0ff;
            border-radius: 50%;
            opacity: 0.5;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #0ff;
        }

        .crosshair::before {
            width: 2px;
            height: 15px;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crosshair::after {
            width: 15px;
            height: 2px;
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
        }

        #interaction-prompt {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 255, 0.2);
            padding: 15px 30px;
            border: 2px solid #0ff;
            border-radius: 10px;
            font-size: 18px;
            display: none;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        #upgrade-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #0ff;
            border-radius: 10px;
            padding: 30px;
            display: none;
            z-index: 20;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            pointer-events: auto;
        }

        #upgrade-menu.visible {
            display: block;
        }

        .menu-title {
            font-size: 28px;
            margin-bottom: 20px;
            text-align: center;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
        }

        .upgrade-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .upgrade-card {
            background: rgba(0, 100, 100, 0.2);
            border: 2px solid #0ff;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upgrade-card:hover:not(.disabled) {
            background: rgba(0, 150, 150, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px #0ff;
        }

        .upgrade-card.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .upgrade-name {
            font-size: 20px;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .upgrade-description {
            font-size: 14px;
            margin-bottom: 10px;
            color: #8ff;
        }

        .upgrade-cost {
            font-size: 14px;
            margin-bottom: 5px;
            color: #ff0;
        }

        .upgrade-level {
            font-size: 14px;
            color: #0f0;
        }

        .menu-close {
            text-align: center;
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }

        #help-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #0ff;
            border-radius: 10px;
            padding: 30px;
            display: none;
            z-index: 20;
            max-width: 600px;
            pointer-events: auto;
        }

        #help-screen.visible {
            display: block;
        }

        .help-section {
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: #0ff;
            margin-bottom: 10px;
            font-size: 20px;
        }

        .help-section p {
            color: #8ff;
            line-height: 1.6;
            margin-bottom: 5px;
        }

        #planet-info {
            position: absolute;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border: 2px solid #0ff;
            border-radius: 5px;
            display: none;
            text-align: center;
        }

        #surface-hud {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 5px;
            display: none;
            text-align: center;
        }

        .message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 255, 0, 0.2);
            padding: 10px 20px;
            border: 2px solid #0f0;
            border-radius: 5px;
            display: none;
            z-index: 30;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div id="loading">Loading Space Fighter...</div>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-top">
            <div class="hud-stats">
                <div>Speed: <span id="speed">0</span> u/s</div>
                <div>Cargo: <span id="cargo-used">0</span>/<span id="cargo-max">20</span></div>
            </div>
            <div class="hud-stats resources">
                <div class="resource-item">Iron: <span id="res-iron">0</span></div>
                <div class="resource-item">Water: <span id="res-water">0</span></div>
                <div class="resource-item">Rare Metal: <span id="res-rare">0</span></div>
                <div class="resource-item">Helium: <span id="res-helium">0</span></div>
            </div>
        </div>
    </div>

    <div class="crosshair"></div>

    <div id="interaction-prompt">Look at a planet and press L to land</div>
    <div id="planet-info"></div>
    <div id="surface-hud">
        <div>On Planet Surface - Collect Resources</div>
        <div style="margin-top: 10px; font-size: 14px;">WASD/Arrow Keys to move • E to collect resources • Return to ship and press E to take off</div>
    </div>

    <!-- Upgrade Menu -->
    <div id="upgrade-menu">
        <div class="menu-title">SHIP UPGRADES</div>
        <div class="upgrade-grid" id="upgrade-grid"></div>
        <div class="menu-close">Press TAB to close</div>
    </div>

    <!-- Help Screen -->
    <div id="help-screen">
        <div class="menu-title">SPACE FIGHTER - CONTROLS</div>
        <div class="help-section">
            <h3>Flight Controls</h3>
            <p>W / S / Arrow Keys - Forward / Backward thrust</p>
            <p>A / D / Arrow Keys - Strafe left / right</p>
            <p>Mouse - Look around</p>
        </div>
        <div class="help-section">
            <h3>Combat</h3>
            <p>Spacebar / Left Mouse - Shoot (destroy enemy ships)</p>
        </div>
        <div class="help-section">
            <h3>Interactions</h3>
            <p>L - Land on planet (look at planet and press L)</p>
            <p>E - Collect resources / Take off (when on planet surface)</p>
            <p>TAB - Open upgrade menu</p>
            <p>I - Toggle this help screen</p>
        </div>
        <div class="help-section">
            <h3>Objective</h3>
            <p>Explore planets, gather resources, and upgrade your ship!</p>
            <p>Each planet has different resources to collect.</p>
        </div>
        <div class="menu-close">Press I to close</div>
    </div>

    <div id="message" class="message"></div>

    <!-- Three.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>

    <script>
        console.log('Space Fighter script loading...');

        // Main Game Object
        const SpaceGame = {
            // Three.js objects
            scene: null,
            camera: null,
            renderer: null,
            stars: null,
            sun: null,

            // Game state
            state: 'FLYING', // FLYING, LANDED, MENU
            time: 0,

            // Player data
            player: {
                position: new THREE.Vector3(0, 0, 200),
                velocity: new THREE.Vector3(0, 0, 0),
                rotation: { yaw: 0, pitch: 0 },
                resources: { iron: 0, water: 0, rare: 0, helium: 0 },
                upgrades: { engine: 0, cargo: 0, fuel: 0, scanner: 0, weapon: 0, fireRate: 0, bulletType: 0 },
                speed: 0,
                maxSpeed: 50,
                cargoCapacity: 20,
                fireRate: 3,
                bulletDamage: 10,
                bulletSpeed: 200,
                lastShotTime: -10
            },

            // Bullets
            bullets: [],

            // Enemies
            enemies: [],
            enemySpawnTimer: 0,
            enemySpawnInterval: 5,

            // Planets
            planets: [],
            currentPlanet: null,
            nearestPlanet: null,

            // Surface objects
            surfaceScene: null,
            surfaceResources: [],
            surfaceUpgrades: [],
            playerShip: null,

            // Controls
            keys: {},
            mouse: { x: 0, y: 0, locked: false },
            shooting: false,

            // Upgrade definitions
            upgradeDefinitions: {
                engine: {
                    name: 'Engine Upgrade',
                    description: 'Increases maximum speed',
                    cost: { iron: 10, rare: 2 },
                    maxLevel: 5,
                    effect: (level) => 50 + level * 20
                },
                cargo: {
                    name: 'Cargo Bay',
                    description: 'Increases resource capacity',
                    cost: { iron: 5, rare: 2 },
                    maxLevel: 5,
                    effect: (level) => 20 + level * 10
                },
                fuel: {
                    name: 'Fuel Efficiency',
                    description: 'Reduces fuel consumption',
                    cost: { water: 8, helium: 1 },
                    maxLevel: 3,
                    effect: (level) => level
                },
                scanner: {
                    name: 'Resource Scanner',
                    description: 'Shows resource locations on planets',
                    cost: { rare: 5, helium: 2 },
                    maxLevel: 1,
                    effect: (level) => level
                },
                weapon: {
                    name: 'Weapon Power',
                    description: 'Increases bullet damage',
                    cost: { iron: 8, rare: 3 },
                    maxLevel: 5,
                    effect: (level) => 10 + level * 5
                },
                fireRate: {
                    name: 'Fire Rate',
                    description: 'Shoot faster',
                    cost: { iron: 6, water: 4 },
                    maxLevel: 5,
                    effect: (level) => 3 + level * 2
                },
                bulletType: {
                    name: 'Multi-Shot',
                    description: 'Fire multiple bullets at once',
                    cost: { rare: 10, helium: 5 },
                    maxLevel: 2,
                    effect: (level) => level
                }
            },

            // Planet type definitions
            planetTypes: [
                { name: 'Rocky', color: 0x8B7355, resources: ['iron', 'iron', 'iron', 'water'] },
                { name: 'Ice', color: 0x87CEEB, resources: ['water', 'water', 'water', 'helium'] },
                { name: 'Volcanic', color: 0xFF4500, resources: ['rare', 'rare', 'iron', 'helium'] },
                { name: 'Desert', color: 0xDEB887, resources: ['iron', 'rare', 'water'] },
                { name: 'Gas Giant', color: 0xFFA500, resources: ['helium', 'helium', 'helium'] },
                { name: 'Jungle', color: 0x228B22, resources: ['water', 'iron', 'rare', 'helium'] }
            ],

            // Initialize game
            init() {
                console.log('Initializing Space Fighter...');

                // Load saved game
                this.loadGame();

                // Setup Three.js
                this.setupRenderer();
                this.setupScene();
                this.setupLighting();
                this.createStarfield();
                this.createSun();
                this.createPlanets();

                // Setup controls
                this.setupControls();

                // Setup UI
                this.setupUI();

                // Hide loading screen
                document.getElementById('loading').style.display = 'none';

                // Start game loop
                this.lastTime = performance.now();
                this.animate();

                console.log('Space Fighter initialized!');
            },

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Setup camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    10000
                );

                // Handle window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            },

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.00015);
            },

            setupLighting() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);
            },

            createStarfield() {
                const starsGeometry = new THREE.BufferGeometry();
                const starsMaterial = new THREE.PointsMaterial({
                    color: 0xFFFFFF,
                    size: 2,
                    sizeAttenuation: false
                });

                const starsVertices = [];
                for (let i = 0; i < 10000; i++) {
                    const x = (Math.random() - 0.5) * 4000;
                    const y = (Math.random() - 0.5) * 4000;
                    const z = (Math.random() - 0.5) * 4000;
                    starsVertices.push(x, y, z);
                }

                starsGeometry.setAttribute('position',
                    new THREE.Float32BufferAttribute(starsVertices, 3));

                this.stars = new THREE.Points(starsGeometry, starsMaterial);
                this.scene.add(this.stars);
            },

            createSun() {
                const sunGeometry = new THREE.SphereGeometry(50, 32, 32);
                const sunMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFDB813,
                    emissive: 0xFDB813,
                    emissiveIntensity: 1
                });
                this.sun = new THREE.Mesh(sunGeometry, sunMaterial);
                this.sun.position.set(0, 0, 0);
                this.scene.add(this.sun);

                // Sun light
                const sunLight = new THREE.PointLight(0xFFFFAA, 2, 3000);
                sunLight.position.set(0, 0, 0);
                this.scene.add(sunLight);
            },

            createPlanets() {
                const distances = [200, 350, 500, 650, 850, 1000];

                for (let i = 0; i < 6; i++) {
                    const planetType = this.planetTypes[i];
                    const size = 20 + Math.random() * 30;
                    const distance = distances[i];
                    const angle = (Math.PI * 2 / 6) * i;

                    const geometry = new THREE.SphereGeometry(size, 32, 32);
                    const material = new THREE.MeshLambertMaterial({
                        color: planetType.color
                    });
                    const mesh = new THREE.Mesh(geometry, material);

                    mesh.position.x = Math.cos(angle) * distance;
                    mesh.position.z = Math.sin(angle) * distance;
                    mesh.position.y = (Math.random() - 0.5) * 100;

                    this.scene.add(mesh);

                    this.planets.push({
                        mesh: mesh,
                        type: planetType,
                        size: size,
                        distance: distance,
                        angle: angle
                    });
                }
            },

            setupControls() {
                // Keyboard
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key.toLowerCase()] = true;
                    this.keys[e.key] = true; // Also store non-lowercase for special keys like ' '

                    if (e.key === ' ') {
                        e.preventDefault();
                        this.shooting = true;
                    }
                    if (e.key.toLowerCase() === 'l' && this.state === 'FLYING') {
                        this.handleInteraction();
                    }
                    if (e.key.toLowerCase() === 'e' && this.state === 'LANDED') {
                        this.handleInteraction();
                    }
                    if (e.key.toLowerCase() === 'i') {
                        this.toggleHelp();
                    }
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        this.toggleUpgradeMenu();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    this.keys[e.key.toLowerCase()] = false;
                    this.keys[e.key] = false; // Also clear non-lowercase version

                    if (e.key === ' ') {
                        this.shooting = false;
                    }
                });

                // Mouse
                document.addEventListener('pointerlockchange', () => {
                    this.mouse.locked = document.pointerLockElement === this.renderer.domElement;
                });

                this.renderer.domElement.addEventListener('click', () => {
                    if (this.state === 'FLYING') {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                document.addEventListener('mousemove', (e) => {
                    if (this.mouse.locked && this.state === 'FLYING') {
                        this.player.rotation.yaw -= e.movementX * 0.002;
                        this.player.rotation.pitch -= e.movementY * 0.002;
                        this.player.rotation.pitch = Math.max(-Math.PI / 2,
                            Math.min(Math.PI / 2, this.player.rotation.pitch));
                    }
                });

                // Mouse button for shooting
                document.addEventListener('mousedown', (e) => {
                    if (this.state === 'FLYING' && e.button === 0) {
                        if (!this.mouse.locked) {
                            // Request pointer lock on first click
                            this.renderer.domElement.requestPointerLock();
                        }
                        this.shoot();
                    }
                });
            },

            setupUI() {
                this.updateHUD();
                this.updateUpgradeMenu();
            },

            handleInput(deltaTime) {
                if (this.state === 'FLYING') {
                    this.handleFlightInput(deltaTime);
                } else if (this.state === 'LANDED') {
                    this.handleSurfaceInput(deltaTime);
                }
            },

            handleFlightInput(deltaTime) {
                const acceleration = 100 * deltaTime;
                const damping = 0.95;

                // Create direction vectors based on camera rotation
                const forward = new THREE.Vector3(
                    Math.sin(this.player.rotation.yaw),
                    0,
                    Math.cos(this.player.rotation.yaw)
                );

                const right = new THREE.Vector3(
                    Math.cos(this.player.rotation.yaw),
                    0,
                    -Math.sin(this.player.rotation.yaw)
                );

                // Forward/backward
                if (this.keys['w'] || this.keys['arrowup']) {
                    this.player.velocity.add(forward.clone().multiplyScalar(acceleration));
                }
                if (this.keys['s'] || this.keys['arrowdown']) {
                    this.player.velocity.add(forward.clone().multiplyScalar(-acceleration));
                }

                // Strafe
                if (this.keys['a'] || this.keys['arrowleft']) {
                    this.player.velocity.add(right.clone().multiplyScalar(-acceleration));
                }
                if (this.keys['d'] || this.keys['arrowright']) {
                    this.player.velocity.add(right.clone().multiplyScalar(acceleration));
                }

                // Shooting with spacebar
                if (this.shooting) {
                    this.shoot();
                }

                // Apply damping
                this.player.velocity.multiplyScalar(damping);

                // Limit max speed
                const speed = this.player.velocity.length();
                if (speed > this.player.maxSpeed) {
                    this.player.velocity.multiplyScalar(this.player.maxSpeed / speed);
                }

                this.player.speed = speed;

                // Update position
                this.player.position.add(
                    this.player.velocity.clone().multiplyScalar(deltaTime)
                );
            },

            handleSurfaceInput(deltaTime) {
                const speed = 50 * deltaTime;

                if (this.keys['w'] || this.keys['arrowup']) this.player.position.z -= speed;
                if (this.keys['s'] || this.keys['arrowdown']) this.player.position.z += speed;
                if (this.keys['a'] || this.keys['arrowleft']) this.player.position.x -= speed;
                if (this.keys['d'] || this.keys['arrowright']) this.player.position.x += speed;

                // Keep on surface
                this.player.position.y = 10;
            },

            handleInteraction() {
                if (this.state === 'FLYING') {
                    // Check if looking at a planet
                    const targetPlanet = this.getPlanetInCrosshair();
                    if (targetPlanet) {
                        this.landOnPlanet(targetPlanet);
                    }
                } else if (this.state === 'LANDED') {
                    // Check for resource collection
                    this.collectNearbyResource();
                    // Check for ship proximity to take off
                    this.checkTakeoff();
                }
            },

            getPlanetInCrosshair() {
                // Create raycaster from camera
                const raycaster = new THREE.Raycaster();

                // Set ray from camera position in direction camera is facing
                const direction = new THREE.Vector3(
                    Math.sin(this.player.rotation.yaw) * Math.cos(this.player.rotation.pitch),
                    Math.sin(this.player.rotation.pitch),
                    Math.cos(this.player.rotation.yaw) * Math.cos(this.player.rotation.pitch)
                );
                direction.normalize();

                raycaster.set(this.player.position, direction);

                // Check intersection with planet meshes
                const planetMeshes = this.planets.map(p => p.mesh);
                const intersects = raycaster.intersectObjects(planetMeshes);

                if (intersects.length > 0) {
                    // Find which planet was hit
                    for (let planet of this.planets) {
                        if (planet.mesh === intersects[0].object) {
                            return planet;
                        }
                    }
                }

                return null;
            },

            shoot() {
                const currentTime = this.time;
                const fireDelay = 1 / this.player.fireRate;

                if (currentTime - this.player.lastShotTime < fireDelay) {
                    return; // Still in cooldown
                }

                this.player.lastShotTime = currentTime;

                // Calculate bullet direction from camera
                const direction = new THREE.Vector3(
                    Math.sin(this.player.rotation.yaw) * Math.cos(this.player.rotation.pitch),
                    Math.sin(this.player.rotation.pitch),
                    Math.cos(this.player.rotation.yaw) * Math.cos(this.player.rotation.pitch)
                );

                const bulletCount = 1 + this.player.upgrades.bulletType;

                for (let i = 0; i < bulletCount; i++) {
                    let bulletDir = direction.clone();

                    // Spread bullets if multi-shot
                    if (bulletCount > 1) {
                        const spread = (i - (bulletCount - 1) / 2) * 0.1;
                        const right = new THREE.Vector3(
                            Math.cos(this.player.rotation.yaw),
                            0,
                            -Math.sin(this.player.rotation.yaw)
                        );
                        bulletDir.add(right.multiplyScalar(spread));
                        bulletDir.normalize();
                    }

                    const bulletGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const bulletMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00FF00,
                        emissive: 0x00FF00
                    });
                    const bulletMesh = new THREE.Mesh(bulletGeometry, bulletMaterial);

                    bulletMesh.position.copy(this.player.position);
                    this.scene.add(bulletMesh);

                    this.bullets.push({
                        mesh: bulletMesh,
                        velocity: bulletDir.multiplyScalar(this.player.bulletSpeed),
                        damage: this.player.bulletDamage,
                        lifetime: 5
                    });
                }
            },

            updateBullets(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];

                    // Update position
                    bullet.mesh.position.add(bullet.velocity.clone().multiplyScalar(deltaTime));
                    bullet.lifetime -= deltaTime;

                    // Remove if expired
                    if (bullet.lifetime <= 0) {
                        this.scene.remove(bullet.mesh);
                        this.bullets.splice(i, 1);
                        continue;
                    }

                    // Check collision with enemies
                    for (let j = this.enemies.length - 1; j >= 0; j--) {
                        const enemy = this.enemies[j];
                        const distance = bullet.mesh.position.distanceTo(enemy.mesh.position);

                        if (distance < 5) {
                            enemy.health -= bullet.damage;

                            // Remove bullet
                            this.scene.remove(bullet.mesh);
                            this.bullets.splice(i, 1);

                            // Check if enemy destroyed
                            if (enemy.health <= 0) {
                                this.destroyEnemy(j);
                            }

                            break;
                        }
                    }
                }
            },

            spawnEnemy() {
                // Random position around player
                const angle = Math.random() * Math.PI * 2;
                const distance = 300 + Math.random() * 200;
                const height = (Math.random() - 0.5) * 100;

                const position = new THREE.Vector3(
                    this.player.position.x + Math.cos(angle) * distance,
                    this.player.position.y + height,
                    this.player.position.z + Math.sin(angle) * distance
                );

                // Create enemy ship (pyramid shape)
                const geometry = new THREE.ConeGeometry(5, 10, 4);
                const material = new THREE.MeshLambertMaterial({
                    color: 0xFF0000,
                    emissive: 0xFF0000,
                    emissiveIntensity: 0.3
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                mesh.rotation.x = Math.PI;

                this.scene.add(mesh);

                this.enemies.push({
                    mesh: mesh,
                    health: 30,
                    speed: 30,
                    target: this.player.position.clone()
                });
            },

            updateEnemies(deltaTime) {
                // Spawn enemies periodically
                this.enemySpawnTimer += deltaTime;
                if (this.enemySpawnTimer >= this.enemySpawnInterval && this.enemies.length < 10) {
                    this.spawnEnemy();
                    this.enemySpawnTimer = 0;
                }

                // Update each enemy
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];

                    // Move toward player
                    const direction = this.player.position.clone()
                        .sub(enemy.mesh.position)
                        .normalize();

                    enemy.mesh.position.add(direction.multiplyScalar(enemy.speed * deltaTime));

                    // Rotate to face player
                    enemy.mesh.lookAt(this.player.position);
                    enemy.mesh.rotation.x = Math.PI;

                    // Simple bobbing animation
                    enemy.mesh.rotation.y += deltaTime * 2;

                    // Check if too close to player (game over or damage)
                    const distance = enemy.mesh.position.distanceTo(this.player.position);
                    if (distance < 10) {
                        this.destroyEnemy(i);
                        this.showMessage('Enemy ship collided with you!');
                    }
                }
            },

            destroyEnemy(index) {
                const enemy = this.enemies[index];
                this.scene.remove(enemy.mesh);
                this.enemies.splice(index, 1);

                // Award resources
                const resourceTypes = ['iron', 'water', 'rare', 'helium'];
                const randomResource = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];

                const totalCargo = this.player.resources.iron +
                    this.player.resources.water +
                    this.player.resources.rare +
                    this.player.resources.helium;

                if (totalCargo < this.player.cargoCapacity) {
                    this.player.resources[randomResource] += 1;
                    this.showMessage(`Enemy destroyed! +1 ${randomResource}`);
                    this.saveGame();
                } else {
                    this.showMessage('Enemy destroyed! (Cargo full)');
                }
            },

            landOnPlanet(planet) {
                console.log('Landing on planet:', planet.type.name);
                this.state = 'LANDED';
                this.currentPlanet = planet;

                // Create surface scene
                this.createSurfaceScene(planet);

                // Update UI
                document.getElementById('surface-hud').style.display = 'block';
                document.getElementById('interaction-prompt').style.display = 'none';

                this.showMessage(`Landed on ${planet.type.name} planet`);
            },

            createSurfaceScene(planet) {
                // Clear main scene
                this.scene.visible = false;

                // Create surface scene
                this.surfaceScene = new THREE.Scene();
                this.surfaceScene.fog = new THREE.Fog(planet.type.color, 50, 300);

                // Lighting
                const ambLight = new THREE.AmbientLight(0x404040);
                this.surfaceScene.add(ambLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(50, 50, 50);
                this.surfaceScene.add(dirLight);

                // Ground
                const groundGeometry = new THREE.PlaneGeometry(500, 500);
                const groundMaterial = new THREE.MeshLambertMaterial({
                    color: planet.type.color
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                this.surfaceScene.add(ground);

                // Player ship
                const shipGeometry = new THREE.ConeGeometry(5, 15, 8);
                const shipMaterial = new THREE.MeshLambertMaterial({ color: 0x888888 });
                this.playerShip = new THREE.Mesh(shipGeometry, shipMaterial);
                this.playerShip.position.set(0, 7.5, 0);
                this.surfaceScene.add(this.playerShip);

                // Spawn resources
                this.surfaceResources = [];
                const resourceCount = 3 + Math.floor(Math.random() * 3);

                for (let i = 0; i < resourceCount; i++) {
                    const resourceType = planet.type.resources[
                        Math.floor(Math.random() * planet.type.resources.length)
                    ];

                    const colors = {
                        iron: 0x999999,
                        water: 0x0099FF,
                        rare: 0xFF00FF,
                        helium: 0xFFFF00
                    };

                    const geometry = new THREE.OctahedronGeometry(3);
                    const material = new THREE.MeshLambertMaterial({
                        color: colors[resourceType],
                        emissive: colors[resourceType],
                        emissiveIntensity: 0.5
                    });
                    const mesh = new THREE.Mesh(geometry, material);

                    // Random position
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 30 + Math.random() * 80;
                    mesh.position.x = Math.cos(angle) * distance;
                    mesh.position.z = Math.sin(angle) * distance;
                    mesh.position.y = 3;

                    this.surfaceScene.add(mesh);

                    this.surfaceResources.push({
                        mesh: mesh,
                        type: resourceType,
                        collected: false
                    });
                }

                // Spawn upgrade items (rare chance)
                this.surfaceUpgrades = [];
                if (Math.random() < 0.3) { // 30% chance for upgrade on planet
                    const upgradeTypes = ['engine', 'cargo', 'weapon', 'fireRate', 'scanner', 'bulletType'];
                    const upgradeType = upgradeTypes[Math.floor(Math.random() * upgradeTypes.length)];

                    // Box shape for upgrades
                    const geometry = new THREE.BoxGeometry(4, 4, 4);
                    const material = new THREE.MeshLambertMaterial({
                        color: 0x00FFFF,
                        emissive: 0x00FFFF,
                        emissiveIntensity: 0.7
                    });
                    const mesh = new THREE.Mesh(geometry, material);

                    // Random position far from ship
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 100 + Math.random() * 80;
                    mesh.position.x = Math.cos(angle) * distance;
                    mesh.position.z = Math.sin(angle) * distance;
                    mesh.position.y = 4;

                    this.surfaceScene.add(mesh);

                    this.surfaceUpgrades.push({
                        mesh: mesh,
                        type: upgradeType,
                        collected: false
                    });
                }

                // Position player near ship
                this.player.position.set(15, 10, 15);
                this.player.rotation.yaw = 0;
                this.player.rotation.pitch = -0.3;
            },

            collectNearbyResource() {
                const collectDistance = 15;

                // Check for upgrades first
                for (let upgrade of this.surfaceUpgrades) {
                    if (upgrade.collected) continue;

                    const distance = this.player.position.distanceTo(upgrade.mesh.position);
                    if (distance < collectDistance) {
                        const def = this.upgradeDefinitions[upgrade.type];

                        if (this.player.upgrades[upgrade.type] >= def.maxLevel) {
                            this.showMessage(`${def.name} already maxed out!`);
                            return;
                        }

                        // Apply upgrade
                        this.player.upgrades[upgrade.type]++;
                        upgrade.collected = true;
                        this.surfaceScene.remove(upgrade.mesh);

                        // Update ship stats
                        if (upgrade.type === 'engine') {
                            this.player.maxSpeed = def.effect(this.player.upgrades[upgrade.type]);
                        } else if (upgrade.type === 'cargo') {
                            this.player.cargoCapacity = def.effect(this.player.upgrades[upgrade.type]);
                        } else if (upgrade.type === 'weapon') {
                            this.player.bulletDamage = def.effect(this.player.upgrades[upgrade.type]);
                        } else if (upgrade.type === 'fireRate') {
                            this.player.fireRate = def.effect(this.player.upgrades[upgrade.type]);
                        }

                        this.showMessage(`Found ${def.name} upgrade!`);
                        this.updateHUD();
                        this.saveGame();
                        return;
                    }
                }

                // Check for resources
                for (let resource of this.surfaceResources) {
                    if (resource.collected) continue;

                    const distance = this.player.position.distanceTo(resource.mesh.position);
                    if (distance < collectDistance) {
                        // Check cargo capacity
                        const totalCargo = this.player.resources.iron +
                            this.player.resources.water +
                            this.player.resources.rare +
                            this.player.resources.helium;

                        if (totalCargo >= this.player.cargoCapacity) {
                            this.showMessage('Cargo bay full!');
                            return;
                        }

                        // Collect resource
                        this.player.resources[resource.type]++;
                        resource.collected = true;
                        this.surfaceScene.remove(resource.mesh);

                        this.showMessage(`Collected ${resource.type}!`);
                        this.updateHUD();
                        this.saveGame();
                        return;
                    }
                }
            },

            checkTakeoff() {
                const distance = this.player.position.distanceTo(this.playerShip.position);
                if (distance < 20) {
                    this.takeOff();
                }
            },

            takeOff() {
                console.log('Taking off...');
                this.state = 'FLYING';
                this.currentPlanet = null;

                // Restore space scene
                this.scene.visible = true;
                this.surfaceScene = null;
                this.surfaceResources = [];
                this.surfaceUpgrades = [];
                this.playerShip = null;

                // Position player away from planet
                const planet = this.nearestPlanet;
                if (planet) {
                    const direction = this.player.position.clone()
                        .sub(planet.mesh.position).normalize();
                    this.player.position.copy(planet.mesh.position)
                        .add(direction.multiplyScalar(planet.size + 50));
                }

                // Update UI
                document.getElementById('surface-hud').style.display = 'none';

                this.showMessage('Launched into space!');
            },

            toggleUpgradeMenu() {
                const menu = document.getElementById('upgrade-menu');
                menu.classList.toggle('visible');

                if (menu.classList.contains('visible')) {
                    this.updateUpgradeMenu();
                }
            },

            toggleHelp() {
                const help = document.getElementById('help-screen');
                help.classList.toggle('visible');
            },

            updateUpgradeMenu() {
                const grid = document.getElementById('upgrade-grid');
                grid.innerHTML = '';

                for (let [key, def] of Object.entries(this.upgradeDefinitions)) {
                    const currentLevel = this.player.upgrades[key];
                    const canAfford = this.canAffordUpgrade(key);
                    const maxed = currentLevel >= def.maxLevel;

                    const card = document.createElement('div');
                    card.className = 'upgrade-card';
                    if (!canAfford || maxed) card.classList.add('disabled');

                    let costText = '';
                    for (let [resource, amount] of Object.entries(def.cost)) {
                        const resName = resource === 'rare' ? 'Rare Metal' :
                            resource.charAt(0).toUpperCase() + resource.slice(1);
                        costText += `${resName}: ${amount} `;
                    }

                    card.innerHTML = `
                        <div class="upgrade-name">${def.name}</div>
                        <div class="upgrade-description">${def.description}</div>
                        <div class="upgrade-cost">Cost: ${costText}</div>
                        <div class="upgrade-level">Level: ${currentLevel}/${def.maxLevel}</div>
                    `;

                    if (canAfford && !maxed) {
                        card.addEventListener('click', () => {
                            this.purchaseUpgrade(key);
                        });
                    }

                    grid.appendChild(card);
                }
            },

            canAffordUpgrade(upgradeKey) {
                const def = this.upgradeDefinitions[upgradeKey];
                for (let [resource, amount] of Object.entries(def.cost)) {
                    if (this.player.resources[resource] < amount) {
                        return false;
                    }
                }
                return true;
            },

            purchaseUpgrade(upgradeKey) {
                const def = this.upgradeDefinitions[upgradeKey];

                if (!this.canAffordUpgrade(upgradeKey)) return;
                if (this.player.upgrades[upgradeKey] >= def.maxLevel) return;

                // Deduct resources
                for (let [resource, amount] of Object.entries(def.cost)) {
                    this.player.resources[resource] -= amount;
                }

                // Apply upgrade
                this.player.upgrades[upgradeKey]++;

                // Update ship stats
                if (upgradeKey === 'engine') {
                    this.player.maxSpeed = def.effect(this.player.upgrades[upgradeKey]);
                } else if (upgradeKey === 'cargo') {
                    this.player.cargoCapacity = def.effect(this.player.upgrades[upgradeKey]);
                } else if (upgradeKey === 'weapon') {
                    this.player.bulletDamage = def.effect(this.player.upgrades[upgradeKey]);
                } else if (upgradeKey === 'fireRate') {
                    this.player.fireRate = def.effect(this.player.upgrades[upgradeKey]);
                }

                this.showMessage(`${def.name} upgraded!`);
                this.updateUpgradeMenu();
                this.updateHUD();
                this.saveGame();
            },

            updateHUD() {
                document.getElementById('speed').textContent = Math.round(this.player.speed);

                const totalCargo = this.player.resources.iron +
                    this.player.resources.water +
                    this.player.resources.rare +
                    this.player.resources.helium;
                document.getElementById('cargo-used').textContent = totalCargo;
                document.getElementById('cargo-max').textContent = this.player.cargoCapacity;

                document.getElementById('res-iron').textContent = this.player.resources.iron;
                document.getElementById('res-water').textContent = this.player.resources.water;
                document.getElementById('res-rare').textContent = this.player.resources.rare;
                document.getElementById('res-helium').textContent = this.player.resources.helium;
            },

            checkPlanetProximity() {
                if (this.state !== 'FLYING') return;

                // Check if looking at a planet
                const targetPlanet = this.getPlanetInCrosshair();

                if (targetPlanet) {
                    const distance = this.player.position.distanceTo(targetPlanet.mesh.position);

                    const prompt = document.getElementById('interaction-prompt');
                    prompt.textContent = `Press L to land on ${targetPlanet.type.name} planet`;
                    prompt.style.display = 'block';

                    const info = document.getElementById('planet-info');
                    info.textContent = `${targetPlanet.type.name} - ${Math.round(distance)} units away`;
                    info.style.display = 'block';
                } else {
                    document.getElementById('interaction-prompt').style.display = 'none';
                    document.getElementById('planet-info').style.display = 'none';
                }
            },

            showMessage(text) {
                const msg = document.getElementById('message');
                msg.textContent = text;
                msg.style.display = 'block';

                setTimeout(() => {
                    msg.style.display = 'none';
                }, 3000);
            },

            saveGame() {
                const saveData = {
                    resources: this.player.resources,
                    upgrades: this.player.upgrades
                };
                localStorage.setItem('spaceFighterSave', JSON.stringify(saveData));
            },

            loadGame() {
                const saved = localStorage.getItem('spaceFighterSave');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.player.resources = data.resources;
                        this.player.upgrades = data.upgrades;

                        // Apply upgrades
                        this.player.maxSpeed = this.upgradeDefinitions.engine.effect(
                            this.player.upgrades.engine || 0
                        );
                        this.player.cargoCapacity = this.upgradeDefinitions.cargo.effect(
                            this.player.upgrades.cargo || 0
                        );
                        this.player.bulletDamage = this.upgradeDefinitions.weapon.effect(
                            this.player.upgrades.weapon || 0
                        );
                        this.player.fireRate = this.upgradeDefinitions.fireRate.effect(
                            this.player.upgrades.fireRate || 0
                        );
                    } catch (e) {
                        console.error('Failed to load save:', e);
                    }
                }
            },

            update(deltaTime) {
                this.time += deltaTime;

                // Handle input
                this.handleInput(deltaTime);

                // Update camera position and rotation
                if (this.state === 'FLYING') {
                    this.camera.position.copy(this.player.position);
                    this.camera.rotation.set(
                        this.player.rotation.pitch,
                        this.player.rotation.yaw,
                        0,
                        'YXZ'
                    );

                    // Update bullets and enemies
                    this.updateBullets(deltaTime);
                    this.updateEnemies(deltaTime);

                    // Check planet proximity
                    this.checkPlanetProximity();

                    // Rotate planets slightly
                    this.planets.forEach(planet => {
                        planet.mesh.rotation.y += deltaTime * 0.1;
                    });

                } else if (this.state === 'LANDED' && this.surfaceScene) {
                    this.camera.position.copy(this.player.position);
                    this.camera.rotation.set(
                        this.player.rotation.pitch,
                        this.player.rotation.yaw,
                        0,
                        'YXZ'
                    );

                    // Animate resources
                    this.surfaceResources.forEach(resource => {
                        if (!resource.collected) {
                            resource.mesh.rotation.y += deltaTime * 2;
                            resource.mesh.position.y = 3 + Math.sin(this.time * 2) * 0.5;
                        }
                    });

                    // Animate upgrades
                    this.surfaceUpgrades.forEach(upgrade => {
                        if (!upgrade.collected) {
                            upgrade.mesh.rotation.x += deltaTime;
                            upgrade.mesh.rotation.y += deltaTime * 1.5;
                            upgrade.mesh.position.y = 4 + Math.sin(this.time * 1.5) * 0.8;
                        }
                    });
                }

                // Update HUD
                this.updateHUD();
            },

            render() {
                if (this.state === 'FLYING') {
                    this.renderer.render(this.scene, this.camera);
                } else if (this.state === 'LANDED' && this.surfaceScene) {
                    this.renderer.render(this.surfaceScene, this.camera);
                }
            },

            animate() {
                requestAnimationFrame(() => this.animate());

                const currentTime = performance.now();
                const deltaTime = (currentTime - this.lastTime) / 1000;
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.render();
            }
        };

        // Start game when page loads
        window.addEventListener('load', () => {
            SpaceGame.init();
        });
    </script>
</body>
</html>
